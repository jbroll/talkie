# Guidelines for Writing Clear and Debuggable Functions

# @introduction
These guidelines aim to help you write code that is easier to understand, debug, and maintain. Each section focuses on a specific aspect of good coding practices.

# @handle_special_cases
Handle special cases explicitly:
Identify and handle special cases or edge conditions at the beginning of your function. This clarifies the main logic and improves readability.

# @use_consistent_logic
Use consistent logic patterns:
Apply consistent approaches for similar operations throughout your function. This reduces cognitive load when reading and debugging the code.

# @make_operations_clear
Make the order of operations clear:
Structure your function so that the sequence of operations is obvious. Use comments or separate code blocks to delineate different stages of processing.

# @prefer_explicit_logic
Prefer explicit logic over implicit assumptions:
Write out steps explicitly rather than relying on implied behavior. This makes the code's intention clearer and easier to debug.

# @use_descriptive_names
Use descriptive variable names:
Choose variable names that clearly indicate their purpose or content. This aids in understanding the code's flow without needing to track variable values.

# @simplify_main_logic
Simplify the main logic flow:
Aim for a linear, step-by-step progression in your function. Avoid complex nested conditions where possible.

# @centralize_operations
Centralize similar operations:
Group related operations together. This often allows for more consistent handling and makes it easier to spot potential issues.

# @prioritize_robustness
Prioritize robustness:
Consider potential error cases and handle them gracefully. This might include validating input, handling missing data, or providing default behaviors.

# @use_clear_transformations
Use clear data transformations:
When modifying data structures, make the transformations explicit and easy to follow. Consider breaking complex transformations into separate, well-named helper functions.

# @maintain_single_return
Maintain a single point of return:
Where possible, structure your function to have a single, clear point where it returns its result. This can make it easier to ensure all cases are handled correctly and simplify function exit logic.

# @consider_early_returns
Consider early returns for simpler code structure:
In cases where code structure can be simplified, typically avoiding deep indentation associated with logic statements, and where return values share little or no common processing paths, early returns can be a good practice. Early returns can lead to more readable and maintainable code by reducing nesting and clearly separating different cases.

Example:
```python
def process_data(data):
    if not data:
        return None  # Early return for empty data

    if not validate_data(data):
        return False  # Early return for invalid data

    # Main processing logic
    result = perform_complex_operation(data)
    return result
```

In this example, early returns handle special cases upfront, allowing the main logic to proceed without nested if-statements. This can make the code easier to read and maintain.

Choose between single return points and early returns based on the specific context of your function and which approach leads to clearer, more maintainable code.

# @balance_defensive_coding
Balance defensive coding with established invariants:
While defensive coding is generally a good practice, it's important to consider the established invariants and guarantees of your code. Only implement checks and assumptions where they are truly necessary and not precluded by the code's inherent structure or invariants.

- Analyze your code's invariants and guarantees before adding defensive checks.
- Avoid redundant checks that test for conditions that are already ensured by the code's structure or logic flow.
- Document important invariants to make them explicit for other developers (including your future self).
- When adding defensive code, consider its impact on readability and performance.
- Regularly review and refactor defensive code as the system evolves, removing checks that become unnecessary due to changes in invariants or structure.

Example:
```python
# Unnecessary if the 'items' list is guaranteed to be non-empty by design
def process_items(items):
    if items:  # This check might be unnecessary if 'items' is always non-empty
        for item in items:
            # Process item
    else:
        raise ValueError("Items list is empty")

# Better, if we can guarantee 'items' is never empty:
def process_items(items):
    for item in items:
        # Process item
```

By balancing defensive coding with an understanding of your code's invariants, you can write more efficient, cleaner, and more maintainable code.